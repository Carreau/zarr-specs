Zarr core protocol version 3.0
==============================


Conceptual model
----------------

A Zarr *hierarchy* is a tree structure, where each node in the tree is
either a *group* or an *array*. Group nodes may have children
but array nodes may not.

Each node in a hierarchy has a *name* which is a string of ASCII
characters with some additional constraints. Two sibling nodes cannot 
have the same name. The root node does not have a name.

Each node in a hierarchy has a *path* which uniquely identifies that
node and defines its location within the hierarchy. The path is formed 
by joining together the "/" character, followed by the names of all 
ancestor nodes separated by the "/" character, followed by the name of 
the node itself. For example, the path "/foo/bar" identifies a node 
named "bar", whose parent is named "foo", whose parent is the root of 
the hierarchy. The string "/" identifies the root node.

An array has a fixed number of zero or more *dimensions*. Each dimension has an
integer length. The core protocol only considers the case where the
lengths of all dimensions are finite. However, protocol extensions may
be defined which allow a dimension to have infinite or variable
length.

The *shape* of an array is the tuple of dimension lengths. For
example, if an array has 2 dimensions, where the length of the first
dimension is 100 and the length of the second dimension is 20, then
the shape of the array is (100, 20).

An array contains zero or more *elements*. Each element can be
identified by a tuple of coordinates, one for each dimension of the
array. If all dimensions of an array have finite length, then the
number of elements in the array is given by the product of the
dimension lengths. An array element may be empty, or it may have a
value.

An array is associated with a *data type*. A data type defines the set
of possible values that the array may contain, and a binary
representation (i.e., sequence of bytes) for each possible value. For
example, the little-endian 32-bit signed integer data type defines
binary representations for all integers in the range âˆ’2,147,483,648 to
2,147,483,647. The core protocol only considers a limited set of data
types, but protocol extensions may define other data types.

An array is divided into a set of *chunks*, where each chunk is a
hyperrectangle defined by a tuple of intervals, one for each dimension
of the array. The shape of a chunk is the tuple of interval lengths,
and the size of a chunk (i.e., number of elements contained within the
chunk) is the product of its interval lengths.

The chunks of an array are organised into a *grid*. The core protocol
only considers the case where all chunks have the same shape and the
chunks form a regular grid. However, protocol extensions may define
other grid types such as rectilinear grids.

An array is associated with a *memory layout* which defines how to
construct a binary representation of a single chunk by organising the
binary values within the chunk into a single contiguous sequence of
bytes. The core protocol defines two types of memory layout based on
"C" (row-major) and "F" (column-major) ordering of values, but
protocol extensions may define other memory layouts.

An array is associated with an *encoding pipeline*, which is a
sequence of zero or more *codecs* that transforms the binary
representation of a chunk in some way. For example, an encoding
pipeline might include a checksum codec to ensure data integrity, and
a compression codec to reduce data size. All codecs implement a common
*codec interface* which provides a pair of operations, one to perform
the transformation (encode), the other to reverse the transformation
(decode).

Each node in a hierarchy is represented by a *metadata document*,
which is a machine-readable document containing essential processing
information about the node. For example, an array metadata document
will specify the number of dimensions, length of each dimension, data
type, chunk shape, memory layout and encoding pipeline for that array.

Each node in a hierarchy may have an *attributes document*, which is a
machine-readable document containing information that may be useful to
users of the data but is not essential to the basic processing of the
node.

The metadata, attributes and encoded chunk data for all nodes in a
hierarchy are held in a *store*. To enable a variety of different
store types to be used, the core protocol defines a simple *store
interface* which is a common set of operations that a store must
provide.


Node names
----------

TODO define constraints on node names


Data types
----------

TODO define core data types

Regular chunk grids
-------------------

TODO define regular chunk grids, including how to form a key for each chunk in a grid


Memory layouts
--------------

TODO define "C" and "F" memory layouts

Codec interface
---------------

TODO define the codec interface


Array metadata
--------------

A Zarr array metadata document is a [RFC8259]_ JSON document
containing configuration metadata for a Zarr array. In this section,
the terms "value", "number", "string" and "object" are used as defined
in [RFC8259]_. The term "array" is also used as defined in [RFC8259]_
and means a JSON array, except where qualified as "Zarr
array". Following [RFC8259]_, this section also describes an object as
a set of name/value pairs.

A Zarr array metadata document must contain a single object, here
called the metadata object. The following names must be present in the
metadata object and must be used as defined below.

`zarr_format`

    URI of the Zarr core protocol specification that defines the
    metadata format. For Zarr arrays conforming to this specification,
    the value must be the string
    "http://purl.org/zarr/spec/protocol/core/3.0".

    Implementations of this protocol may assume that the final path
    segment of this URI ("3.0") represents the core protocol version
    number, where "3" is the major version number and "0" is the minor
    version number. Implementations of this protocol may also assume
    that future versions of this protocol that retain the same major
    versioning number ("3") will be backwards-compatible, in the sense
    that any new features added to the protocol can be safely
    ignored. In other words, implementations of this protocol may read
    any metadata object where the major version number is "3" and
    interpret the metadata as defined in this specification, ignoring
    any name/value pairs where the name is not defined here.

    Note that this value is given as a URI rather than just as a
    simple version number string to help with discovery of this
    specification.

`shape`

    An array of integers providing the length of each dimension of the
    Zarr array. For example, a value ``[10, 20]`` indicates a
    two-dimensional Zarr array, where the first dimension has length
    10 and the second dimension has length 20.

`data_type`

    The data type of the Zarr array. If the data type is defined in
    this specification, then the value must be the data type
    identifier provided as a string. For example, ``"<f8"`` for
    little-endian 64-bit floating point number.

    The `data_type` value is an extension point and may be defined by
    a protocol extension. If the data type is defined by a protocol
    extension, then the value must be an object containing the names
    `extension`, `type` and `fallback`. The `extension` is required
    and its value must be a URI that identifies the protocol extension
    and dereferences to a human-readable representation of the
    specification.  The `type` is required and its value is defined by
    the protocol extension. The `fallback` is optional and, if
    provided, its value must be one of the data type identifiers
    defined in this specification. If an implementation does not
    recognise the extension, but a `fallback` is present, then the
    implementation may proceed using the `fallback` value as the data
    type. The object may also contain other name/value pairs as
    defined by the protocol extension.

`chunk_grid`

    The chunk grid of the Zarr array. If the chunk grid is a regular
    chunk grid as defined in this specification, then the value must
    be an object with the names `type` and `chunk_shape`. The value of
    `type` must be the string ``"regular"``, and the value of
    `chunk_shape` must be an array of integers providing the lengths
    of the chunk along each dimension of the array. For example,
    ``{"type": "regular", "chunk_shape": [2, 5]}`` means a regular
    grid where the chunks have length 2 along the first dimension and
    length 5 along the second dimension.

    The `chunk_grid` value is an extension point and may be defined by
    a protocol extension. If the chunk grid type is defined by a
    protocol extension, then the value must be an object containing
    the names `extension` and `type`. The `extension` is required and
    the value must be a URI that identifies the protocol extension and
    dereferences to a human-readable representation of the
    specification.  The `type` is required and the value is defined by
    the protocol extension. The object may also contain other
    name/value pairs as defined by the protocol extension.

`chunk_memory_layout`

    The internal memory layout of the chunks. Use the value ``"C"`` to
    indicate C contiguous memory layout or ``"F"`` to indicate F
    contiguous memory layout as defined in this specification @@TODO
    link to sections@@.

    The `chunk_memory_layout` value is an extension point and may be
    defined by a protocol extension. If the chunk memory layout type
    is defined by a protocol extension, then the value must be an
    object containing the names `extension` and `type`. The
    `extension` is required and the value must be a URI that
    identifies the protocol extension and dereferences to a
    human-readable representation of the specification.  The `type` is
    required and the value is defined by the protocol extension. The
    object may also contain other name/value pairs as defined by the
    protocol extension.

`chunk_codecs`

    Specifies a sequence of zero or more codecs to be used for
    encoding and decoding chunks. The value must be an array, where
    each member of the array is an object that provides configuration
    metadata for a codec. Each codec configuration object must contain
    the name `codec` whose value is a URI that identifies a codec and
    dereferences to a human readable representation of the codec
    specification. Each codec configuration object may contain other
    name/value pairs providing addition configuration metadata, as
    defined by the corresponding codec specification.

    The codec configuration objects must be given in the order that
    the codecs are applied during chunk encoding. I.e., the first
    codec configuration object defines the first codec applied during
    chunk encoding, and the last codec applied during chunk decoding.

`fill_value`

    Provides an element value to use for uninitialised portions of the
    Zarr array.

    If the data type of the Zarr array is Boolean then the value must
    be the literal ``false`` or ``true``. If the data type is one of
    the integer data types defined in this specification, then the
    value must be a number with no fraction or exponent part and must
    be within the range of the data type. TODO what about floating
    point data types? TODO what about complex data types? TODO what
    about nan and inf? TODO what about extension data types?

    For any data type, if the `fill_value` is the literal `null` then
    the fill value is undefined and the implementation may use any
    arbitrary value that is consistent with the data type as the fill
    value.
    
`extensions`

    Provides protocol extensions which define additional features used
    by the Zarr array or other modifications to the metadata
    format. The value must be an array containing zero or more
    objects, each of which identifies an extension used and provides
    any additional extension configuration metadata. Each extension
    configuration object must contain the name `extension` whose value
    is a URI that identifies a Zarr protocol extension and
    dereferences to a human readable representation of the extension
    specification. Each object must also contain the name
    `must_understand` whose value is either the literal ``true`` or
    ``false``. Each object may contain other name/value pairs as
    defined by the protocol extension.

    If an implementation of this specification encounters an extension
    that it does not recognise, but the value of `must_understand` is
    ``false``, then the extension may be ignored and processing may
    continue. If the extension is not recognised and the value of
    `must_understand` is ``true`` then processing must terminate and
    an appropriate error raised.

other names

    All other names are reserved for future versions of this
    specification. Implementations and protocol extensions must not
    define or use any other names within the metadata object. Any
    additional metadata must be provided elsewhere, e.g., within any
    of the extension point values, or within the `extensions`, or in a
    separate metadata object stored under a different key in the
    store. See also the section on `Protocol extensions`_ below.


Group metadata
--------------

TODO define the structure and content of group metadata documents


User attributes
---------------

TODO define attributes documents


Store interface
---------------

TODO define the store interface


Storage protocol
----------------

TODO define how high level operations like creating a group or array 
translate into low level key/value operations on the store interface


Protocol extensions
-------------------

TODO define different types of protocol extension.


References
----------

.. [RFC8259] T. Bray, Ed. The JavaScript Object Notation (JSON) Data
   Interchange Format. December 2017. Best Current Practice. URL:
   https://tools.ietf.org/html/rfc8259
