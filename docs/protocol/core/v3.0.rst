Zarr core protocol version 3.0
==============================


Conceptual model
----------------

A Zarr *hierarchy* is a tree structure, where each node in the tree is
either a *group* or an *array*. Group nodes may have children
but array nodes may not.

Each node in a hierarchy has a *name* which is a string of ASCII
characters with some additional constraints. Two sibling nodes cannot 
have the same name. The root node does not have a name.

Each node in a hierarchy has a *path* which uniquely identifies that
node and defines its location within the hierarchy. The path is formed 
by joining together the "/" character, followed by the names of all 
ancestor nodes separated by the "/" character, followed by the name of 
the node itself. For example, the path "/foo/bar" identifies a node 
named "bar", whose parent is named "foo", whose parent is the root of 
the hierarchy. The string "/" identifies the root node.

An array has a fixed number of zero or more *dimensions*. Each dimension has an
integer length. The core protocol only considers the case where the
lengths of all dimensions are finite. However, protocol extensions may
be defined which allow a dimension to have infinite or variable
length.

The *shape* of an array is the tuple of dimension lengths. For
example, if an array has 2 dimensions, where the length of the first
dimension is 100 and the length of the second dimension is 20, then
the shape of the array is (100, 20).

An array contains zero or more *elements*. Each element can be
identified by a tuple of coordinates, one for each dimension of the
array. If all dimensions of an array have finite length, then the
number of elements in the array is given by the product of the
dimension lengths. An array element may be empty, or it may have a
value.

An array is associated with a *data type*. A data type defines the set
of possible values that the array may contain, and a binary
representation (i.e., sequence of bytes) for each possible value. For
example, the little-endian 32-bit signed integer data type defines
binary representations for all integers in the range âˆ’2,147,483,648 to
2,147,483,647. The core protocol only considers a limited set of data
types, but protocol extensions may define other data types.

An array is divided into a set of *chunks*, where each chunk is a
hyperrectangle defined by a tuple of intervals, one for each dimension
of the array. The shape of a chunk is the tuple of interval lengths,
and the size of a chunk (i.e., number of elements contained within the
chunk) is the product of its interval lengths.

The chunks of an array are organised into a *grid*. The core protocol
only considers the case where all chunks have the same shape and the
chunks form a regular grid. However, protocol extensions may define
other grid types such as rectilinear grids.

An array is associated with a *memory layout* which defines how to
construct a binary representation of a single chunk by organising the
binary values within the chunk into a single contiguous sequence of
bytes. The core protocol defines two types of memory layout based on
"C" (row-major) and "F" (column-major) ordering of values, but
protocol extensions may define other memory layouts.

An array is associated with an *encoding pipeline*, which is a
sequence of zero or more *codecs* that transforms the binary
representation of a chunk in some way. For example, an encoding
pipeline might include a checksum codec to ensure data integrity, and
a compression codec to reduce data size. All codecs implement a common
*codec interface* which provides a pair of operations, one to perform
the transformation (encode), the other to reverse the transformation
(decode).

Each node in a hierarchy is represented by a *metadata document*,
which is a machine-readable document containing essential processing
information about the node. For example, an array metadata document
will specify the number of dimensions, length of each dimension, data
type, chunk shape, memory layout and encoding pipeline for that array.

Each node in a hierarchy may have an *attributes document*, which is a
machine-readable document containing information that may be useful to
users of the data but is not essential to the basic processing of the
node.

The metadata, attributes and encoded chunk data for all nodes in a
hierarchy are held in a *store*. To enable a variety of different
store types to be used, the core protocol defines a simple *store
interface* which is a common set of operations that a store must
provide.


Node names
----------

TODO define constraints on node names


Data types
----------

TODO define core data types

Chunk grids
-----------

A chunk grid defines a set of chunks which contain the elements of an
array. The chunks of a grid form a tessellation of the array space,
which is a space defined by the dimensionality and shape of the
array. This means that every element of the array is a member of one
chunk, and there are no gaps or overlaps between chunks.

In general there are different possible types of grids. The core
protocol defines the regular grid type, where all chunks are
hyperrectangles of the same shape. Protocol extensions may define
other grid types, such as rectilinear grids where chunks are still
hyperrectangles but do not all share the same shape.

A grid type also defines rules for constructing a unique key for each
chunk, which is a string of ASCII characters that can be used to save
and retrieve chunk data in a store.

Regular grids
~~~~~~~~~~~~~

A regular grid is a type of grid where an array is divided into chunks
such that each chunk is a hyperrectangle of the same shape. The
dimensionality of the grid is the same as the dimensionality of the
array. Each chunk in the grid can be addressed by a tuple of positive
integers (i, j, k, ...) corresponding to the indices of the chunk
along each dimension.

The origin vertex of a chunk has coordinates in the array space (i *
dx, j * dy, k * dz, ...) where (dx, dy, dz, ...) are the grid spacings
along each dimension, also known as the chunk shape. Thus the origin
vertex of the chunk at grid index (0, 0, 0, ...) is at coordinate (0,
0, 0, ...) in the array space, i.e., the grid is aligned with the
origin of the array. If the length of any array dimension is not
perfectly divisible by the chunk length along the same dimension, then
the grid will overhang the edge of the array space.

The shape of the chunk grid will be (ceil(x / dx), ceil(y / dy),
ceil(z / dz), ...)  where (x, y, z, ...) is the array shape, / is the
division operator and ceil() is the ceiling function. For example, if
a 3 dimensional array has shape (10, 200, 3000), and has chunk shape
(5, 20, 400), then the shape of the chunk grid will be (2, 10, 8),
meaning that there will be 2 chunks along the first dimension, 10
along the second dimension, and 8 along the third dimension.

An element of an array with coordinates (i, j, k, ...) will occur
within the chunk at grid index (i // dx, j // dy, k // dz, ...), where
// is the floor division operator. The element will have coordinates
(i % dx, j % dy, k % dz, ...) within that chunk. For example, @@TODO
example.

The key for chunk with grid index (i, j, k, ...) is formed by joining
together the path of the array in which the chunk occurs, then a
forward slash character ("/"), then a prefix, then the ASCII string
representations of each index, then a suffix. The prefix, chunk
indices and suffix are joined using a separator. The default value for
the prefix is the empty string (""), the default value for the
separator is the period character (".") and the default value for the
suffix is the empty string (""), but these values may be configured,
see the section on `Array metadata`_ below.

For example, in a 3 dimensional array at path "/foo/bar" configured
with default values for the chunk key prefix, suffix and separator,
the key for the chunk at grid index (1, 23, 45) is the string
"/foo/bar/1.23.45".

Note that this specification does not consider the case where the
chunk grid and the array space are not aligned at the origin vertices
of the array and the chunk at grid index (0, 0, 0, ...). However,
protocol extensions may define variations on the regular grid type
such that the grid indices may include negative integers, and the
origin vertex of the array may occur at an arbitrary position within
any chunk, which is required to allow arrays to be extended by an
arbitrary length in a "negative" direction along any dimension.

Memory layouts
--------------

TODO define "C" and "F" memory layouts

Codec interface
---------------

TODO define the codec interface


Array metadata
--------------

TODO define the structure and content of array metadata documents


Group metadata
--------------

TODO define the structure and content of group metadata documents


User attributes
---------------

TODO define attributes documents


Store interface
---------------

TODO define the store interface


Storage protocol
----------------

TODO define how high level operations like creating a group or array 
translate into low level key/value operations on the store interface

